Detection process and retrieving the enter/reset string (only when not in command mode, so do this once at boot only or when you've terminated the command mode):
1. Read port 0xE9 to detect the debugger. If it returns 0xE9, it's there. Else abort.
2. Read bytes from port 0xEA until a 0xFF byte is found to start at the correct value.
3. Read bytes from port 0xEA into a string buffer until a 0xFF end-of-string byte is given.
4. If the read string is empty, command mode doesn't exist. Else, it contains the special identifier string to enter command mode.
Keep this string value ready when working with the debugger. It is used to start and reset the debugger routines to command mode.
Starting/resetting the debugger to the initial command mode:
5. Write a newline followed by the read string (making sure we're at the start of a new line), next followed again by a newline(\n or \r) to port 0xE9 (port E9 hack). This will activate and reset the command mode.
6. Read one byte from port 0xEA. If it returns 0, you have entered command mode and the interpreter is ready to receive a command.

Command mode input/output (byte quantities, bigger values in little endian format):

----------------

COMMAND MODE

Both IN and OUT are done on port 0xEA, after the command mode is enabled.

----------------

All errors redirect to this point in execution, after reading the ERROR(0) code or error codes depending on the function.

OUT First byte: group selection.
IN result (optional): 1 for OK, 0 for error(resets command).
OUT Second byte: function selection.
IN result: 1 for OK, 0 for error (resets command).
Without parameters: a reset to command mode is executed, if it's still active after the command (a quit command won't give a result).

Parameter phase: (depending on the function)
OUT Parameters: Sets the parameters to use.
IN result: 3 for parameters acnowledged and result phase started, 2 for parameters acnowledged and reset to command mode, 1 for not enough/too much written and reset to command mode, 0 for error (reset to command mode).

Without a result, a reset to command mode is executed.

Result phase: (depending on the function)
First read gives the low byte (little endian) of the result size.
Second read gives the high byte (little endian) of the result size.
Above low and high bytes give the size of the below read result data (if any).
Third and further reads give the result data. Overflow or reading no first, second or all result data will cause the result to give an error.

Result verification phase (only with a result phase)
OUT Anyvalue: Moves the result phase to the verification phase, causing an IN to give the result.
IN result: 4 for OK. 0 for error (also caused by the above result phase going wrong (not reading enough or too much)).
After this result is read, command mode is entered again.

----------------

COMMAND LIST

----------------

Values are in little-endian format.

Group #0: Basic functions.
	Function #0:	Quit to debugger.	This will cause the command mode to quit and re-enter normal mode.
	Function #1:	Change output filename: Specify length.
				Parameter:
					WORD The size of the zero-terminated string containing the new filename (word).
				Result:
					1 on success, 0 on error.
	Function #2:	Change output filename: Specify filename (after above function only).
				Parameter:
				The zero-terminated string containing the new filename, of the length in bytes of the specify length command.
Group #1: Disk functions (unimplemented).
	Function #0:	Check for disk mount
			Parameters:
				BYTE disk number (0,1=Floppy; 2,3=HDD, 4,5=CDROM, 6,7,8,9=USB)
			Result:
				BYTE mounted (0 on not mounted, 1 on mounted)
	Function #1:	Swap next disk (based on disk number, starting at 1 (at the end of the filename))
			Parameters:
				BYTE disk number (see above, except HDD)
			Result:
				BYTE OK (1 on same mount, 2 on mounted, 0 on error)
	Function #2:	List available mounts.
			Parameters:
				BYTE disk number (see above, except HDD)
			Result:
				A list of mountable disks:
					Each disk has the following structure:
					WORD disk number
					WORD filename length
					byte filename
	Function #3:	Mount disk
			Parameters:
				WORD disk number
Group #2: Soundfont
	TODO

//C routines for working with the debugger.

int detectCommandMode(char *identifier) //Detection routine. Only use when not in command mode.
{
	while (inp(0xEA)!=0xFF) //Not done yet?
	{
		//Read till start!
	}
	char *identifierpos = identifierholder; //The identifier!
	byte val;
	while ((val = inp(0xEA))!=0xFF) //Not done reading yet?
	{
		*identifierpos++ = val; //Add to the result!
	}
	*identifierpos++ = '\0'; //End of string!
	return !!strcmp(identifier,""); //TRUE on detected, FALSE on not detected!
}

int resetCommandMode(char *identifier) //Enter/reset the command mode (after detection or later)
{
	if (!identifier) return 0; //Not entered: invalid identifier!
	outp(0xE9,'\n');
	outp(0xE9,'\n');
	while (*identifier)
	{
		outp(0xE9,*identifier++); //Process the string!
	}
	outp(0xE9,'\n');
	if (!inp(0xEA)) //Command mode entered?
	{
		return 1;
	}
	return 0; //Failed: command mode not entered!
}