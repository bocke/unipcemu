//Our audio includes!
#include "headers/types.h" //Basic types!
#include "headers/emu/sound.h" //Sound comp.
#include "headers/support/zalloc.h" //Zero allocation!
#include "headers/support/log.h" //Logging support!
#include "headers/support/highrestimer.h" //High resolution clock for timing checks.
#include <pspaudiolib.h>
#include <SDL/SDL.h>

//Are we disabled?
#define __HW_DISABLED 0
//How many samples to process at once? Originally 2048
#define SAMPLESIZE 2048
//Maximum samplerate in Hertz (200KHz)
#define MAX_SAMPLERATE 200000.0f
//Enable below if debugging speed is to be enabled.
//#define DEBUG_SOUNDSPEED
//Enable below if debugging buffering is to be enabled.
//#define DEBUG_SOUNDBUFFER
//Same as speed, but for allocations themselves.
//#define DEBUG_SOUNDALLOC

typedef struct
{
	void *samples; //All samples!
	uint_32 length;		/* size of sound data in bytes */
	uint_32 position;		/* the position in the sound data in bytes */
	uint_32 numsamples; //Ammount of samples in samples.
} sound_t, *sound_p;

/* Structure for a currently playing sound. */
typedef struct
{
	//All our sound data
	sound_t sound;              /* sound data to play from the channel, loaded by the sound handler */
	SOUNDHANDLER soundhandler; //For filling the buffer!

	//Currently executing position
	word position;            /* current position in the sound buffer */
	
	//Rest channel data
	float volume; //The volume!
	float volume_percent; //The volume, in percent (1/volume).
	float samplerate; //The sample rate!
	float convert_samplerate; //Conversion from hardware samplerate to used samplerate!
	uint_32 bufferinc; //The increase in the buffer (how much position decreases during a buffering)
	byte stereo; //Mono stream or stereo stream? 1=Stereo stream, else mono.
	void *extradata; //Extra data for the handler!
	byte init; //Are we a new channel ready to be initialised?
	char name[256]; //A short name!
	byte samplemethod; //The method used to decode samples!
	byte bufferflags; //Special flags about the buffer from the soundhandler function!
} playing_t, *playing_p;

uint_32 soundchannels_used = 0; //Ammount of used sound channels to check, increases as the ammount of entries increase!
playing_t soundchannels[1000]; //All soundchannels!

SDL_AudioSpec audiospecs; //Our requested and obtained audio specifications.

//The sample rate to render at:
#define SW_SAMPLERATE (float)audiospecs.freq

//Sample position precalcs!
uint_32 *samplepos[2]; //Sample positions for mono and stereo channels!
uint_32 samplepos_size; //Size of the sample position precalcs (both of them)

//Default samplerate is HW_SAMPLERATE, Real samplerate is SW_SAMPLERATE

uint_32 audiolocklvl = 0; //Audio lock level!
byte audiolock_paused = 0; //We're paused?

OPTINLINE void lockaudio()
{
	if (!audiolocklvl) //Root level?
	{
		if (SDL_WasInit(SDL_INIT_AUDIO)) //Using SDL and audio enabled?
		{
			SDL_PauseAudio(1); //Pause and lock the sound system so we can safely change our sound data!
			audiolock_paused = 1; //We're paused!
			SDL_LockAudio(); //Lock the audio!
		}		
	}
	++audiolocklvl; //Increase the lock level!
}

OPTINLINE void unlockaudio(byte startplaying)
{
	--audiolocklvl; //Decrease the lock level!
	if (!audiolocklvl) //Root level?
	{
		//We're unlocking!
		if (SDL_WasInit(SDL_INIT_AUDIO)) //SDL loaded and audio enabled?
		{
			SDL_UnlockAudio(); //Unlock the audio!
			if (audiolock_paused) //We're paused?
			{
				if (startplaying) //Start playing again?
				{
					SDL_PauseAudio(0); //Pause and lock the sound system so we can safely change our sound data!
				}
				audiolock_paused = 0; //Not paused anymore!
			}
		}
	}
}

#define C_CALCSAMPLEPOS(rchannel,stereo,time) ((time*(1<<stereo)) + (stereo*rchannel))
static OPTINLINE void calc_samplePos() //Calculate sample position precalcs!
{
	if (samplepos[0] && samplepos[1]) return; //Don't reallocate!
	uint_32 precalcs_size = ((uint_32)MAX_SAMPLERATE*sizeof(*samplepos[0])<<1); //Size of samplepos precalcs!
	//Now allocate the precalcs!
	samplepos[0] = zalloc(precalcs_size,"Sample position precalcs");
	samplepos[1] = zalloc(precalcs_size,"Sample position precalcs");
	byte abort;
	abort = 0; //Default: no abort!
	if (!samplepos[1])
	{
		abort = 1; //1 abort!
	}
	if (!samplepos[0])
	{
		abort |= 2; //2 abort!
	}
	if (abort) //Aborted?
	{
		if (abort&1)
		{
			freez((void **)&samplepos[1],precalcs_size,"Sample position precalcs");
		}
		if (abort&2)
		{
			freez((void **)&samplepos[0],precalcs_size,"Sample position precalcs");
		}
		//Aborted: ran out of memory!
		return; //Abort!
	}
	
	//Now calculate the samplepos precalcs!
	
	uint_32 time = 0;
	uint_32 time_limit = (uint_32)MAX_SAMPLERATE; //The limit!
	//byte stereo; //Whether stereo or not!
	for (;;)
	{
		samplepos[0][(time<<1)|0] = C_CALCSAMPLEPOS(0,0,time); //Precalculate left channel indexes!
		samplepos[0][(time<<1)|1] = C_CALCSAMPLEPOS(1,0,time); //Precalculate right channel indexes!
		samplepos[1][(time<<1)|0] = C_CALCSAMPLEPOS(0,1,time); //Precalculate left channel indexes!
		samplepos[1][(time<<1)|1] = C_CALCSAMPLEPOS(1,1,time); //Precalculate right channel indexes!
		if (++time>=time_limit) break; //Next time position!
	}
	
	samplepos_size = precalcs_size; //The size of the samplepos precalcs!
}

static OPTINLINE void free_samplePos()
{
	byte stereo;
	for (stereo=0;stereo<2;stereo++) //All sample positions!
	{
		if (samplepos[stereo]) //Loaded?
		{
			freez((void **)&samplepos[stereo],samplepos_size,"Sample position precalcs");
		}
	}
	if (!samplepos[0] && !samplepos[1]) //Both freed?
	{
		samplepos_size = 0; //No size anymore: we're freed!
	}
}

int setStereo(SOUNDHANDLER handler, void *extradata, byte stereo) //Channel&Volume(100.0f=100%)
{
	if (__HW_DISABLED) return 0; //Disabled?
	uint_32 n;
	for (n=0;(n<soundchannels_used);n++) //Check all!
	{
		if ((soundchannels[n].soundhandler==handler) && (soundchannels[n].extradata==extradata)) //Found?
		{
			lockaudio();
			soundchannels[n].stereo = stereo; //Are we a stereo channel?
			unlockaudio(1); //Unlock the audio!
			return 1; //Done: check no more!
		}
	}
	return 0; //Not found!
}

/*void releaseSamplerate(word rate) //Release a samplerate precalcs if needed!
{
	lockaudio(); //Lock the audio!
	if (samplerate_used[rate]) //Still used?
	{
		--samplerate_used[rate]; //Decrease the ammount of users for this samplerate!
	}
	if (!samplerate_used[rate] && convert_samplerate[rate]) //Not used anymore, but still allocated?
	{
		freez((void **)&convert_samplerate[rate],convert_sampleratesize[rate],"Samplerate precalcs"); //Release the sample rate!
		if (!convert_samplerate[rate]) //Not allocated anymore?
		{
			convert_sampleratesize[rate] = 0; //Release the size, setting it to unused!
		}
	}
	unlockaudio(1); //Unlock the audio: we're done!
}*/

//Conversion of samplerate!
//#define C_CONVERTSAMPLERATE(t,samplerate) (word)(SAFEDIV(t,(float)SW_SAMPLERATE)*samplerate)

int setSampleRate(SOUNDHANDLER handler, void *extradata, float rate)
{
	if (__HW_DISABLED) return 0; //Disabled?
	//dolog("soundservice","setSampleRate: %f",rate);
	uint_32 n;
	lockaudio(); //Lock the audio!
	for (n=0;n<soundchannels_used;n++) //Check all!
	{
		if (soundchannels[n].soundhandler && (soundchannels[n].soundhandler==handler) && (soundchannels[n].extradata==extradata)) //Found?
		{
			
			/*uint_32 old_samplerate = soundchannels[n].samplerate; //Old samplerate!
			uint_32 samplerate = rate;
			if (!samplerate) //Rate not specified?
			{
				 samplerate = SW_SAMPLERATE; //Default: hardware samplerate!
			}
			soundchannels[n].samplerate = samplerate; //Save the actual samplerate used!
			
			if (samplerate>MAX_SAMPLERATE) //Overflow?
			{
				soundchannels[n].samplerate = 0; //Disabled!
				dolog("soundservice","Samplerate overflow: %i",samplerate); //Invalid samplerate!
				unlockaudio(1); //Unlock the audio: we're done!
				return 0; //Error: invalid samplerate!
			}
			
			if (convert_samplerate[rate]) //Already allocated?
			{
				if (rate!=old_samplerate) //Changed?
				{
					++samplerate_used[rate]; //Increase the ammount of users of this samplerate!
				}
				goto ready; 
			}
			
			//We need to be allocated!
			word realrate = soundchannels[n].samplerate; //Final sample rate!
			convert_samplerate[realrate] = zalloc(realrate*sizeof(*convert_samplerate[realrate]),"Samplerate precalcs"); //Allocate double the maximum sample rate!
			if (!convert_samplerate[rate]) //Error allocating the samplerate precalcs?
			{
				dolog("soundservice","Allocating sample rate failed.");
				soundchannels[n].samplerate = 0; //No samplerate available!
				
				if (old_samplerate) //Old samplerate was set?
				{
					releaseSamplerate(old_samplerate); //Release the old samplerate!
				}
				unlockaudio(1); //Unlock the audio!
				return 0; //Error: couldn't allocate the samplerate precalcs!
			}
			
			//Samplerate allocated, so fill the samplerate precalcs!
			
			//First, release the old samplerate!
			if (old_samplerate!=samplerate) //Different old samplerate? We've changed samplerates!
			{
				releaseSamplerate(old_samplerate); //Release the old samplerate first!
			}
			
			word time = 0;
			for (;;)
			{
				convert_samplerate[rate][time] = C_CONVERTSAMPLERATE(time,realrate); //Precalculate rate conversion channel indexes!
				if (++time>=realrate) break; //Next rate position!
			}
			
			samplerate_used[rate] = 1; //We're the only user of this samplerate atm!
			
			ready: //We're ready to execute!
			*/

			if (rate>(float)MAX_SAMPLERATE) //Too much?
			{
				dolog("soundservice","Maximum samplerate passed: %f",rate); //Maximum samplerate passed!
				unlockaudio(1);
				return 0; //Invalid samplerate!
			}
			
			//Determine the samplerate used first!
			float samplerate = rate;
			if (samplerate==0.0f) //Rate not specified?
			{
				 samplerate = SW_SAMPLERATE; //Default: hardware samplerate!
			}
			
			soundchannels[n].samplerate = samplerate; //Save the actual samplerate used!
			soundchannels[n].convert_samplerate = (1/SW_SAMPLERATE)*samplerate; //The factor for each SW samplerate in destination samplerates!
			soundchannels[n].bufferinc = (uint_32)((float)soundchannels[n].sound.numsamples/(float)soundchannels[n].convert_samplerate); //How much the buffer position decreases during a buffering, in samples!
			
			#ifdef DEBUG_SOUNDALLOC
			dolog("soundservice","Convert samplerate: x%10.5f=SW:%10.5f,Channel:%10.5f; REQ:%10.5f",soundchannels[n].convert_samplerate,SW_SAMPLERATE,samplerate,rate);
			#endif
			
			unlockaudio(1); //Unlock the audio!
			return 1; //OK: we're ready to run!
		}
	}
	unlockaudio(1); //Unlock the audio!
	return 0; //Not found!
}

int setVolume(SOUNDHANDLER handler, void *extradata, float p_volume) //Channel&Volume(100.0f=100%)
{
	if (__HW_DISABLED) return 0; //Disabled?
	uint_32 n;
	lockaudio(); //Lock the audio!
	for (n=0;n<soundchannels_used;n++) //Check all!
	{
		if (soundchannels[n].soundhandler && (soundchannels[n].soundhandler==handler) && (soundchannels[n].extradata==extradata)) //Found?
		{
			soundchannels[n].volume = p_volume; //Set the volume of the channel!
			soundchannels[n].volume_percent = p_volume*0.01f; //The volume in percent!
			unlockaudio(1); //Unlock the audio!
			return 1; //Done: check no more!
		}
	}
	unlockaudio(1); //Unlock the audio!
	return 0; //Not found!
}

//add&removal of channels!

static OPTINLINE uint_32 samplesize(uint_32 samples, byte method)
{
	switch (method)
	{
		case SMPL16: //16 bit unsigned?
		case SMPL16S: //16 bit signed?
			return (samples<<1)*sizeof(short);
			break;
		case SMPL8: //8 bit unsigned?
		case SMPL8S: //8 bit signed?
			return (samples<<1)*sizeof(char);
			break;
		case SMPLFLT: //Floating point numbers?
			return (samples<<1)*sizeof(float);
			break;
		default:
			break;
	}
	return 0; //No size available: invalid size!
}

int addchannel(SOUNDHANDLER handler, void *extradata, char *name, float samplerate, uint_32 samples, byte stereo, byte method) //Adds and gives a 1 on added or 0 on error!
{
	if (__HW_DISABLED) return 0; //Disabled?
	if (!handler) return 0; //Invalid handler!

	#ifdef DEBUG_SOUNDALLOC
	dolog("soundservice","Request: Adding channel at %fHz, buffer every %i samples, Stereo: %i",samplerate,samples,stereo);
	#endif

	if (!samplerate) //Autodetect?
	{
		samplerate = SW_SAMPLERATE; //Automatic samplerate!
		//dolog("soundservice","Autodetect samplerate: %fHz",samplerate); //Autodetect!
	}
	if (!samples) //Autodetect?
	{
		samples = (uint_32)((float)samplerate*((float)(SAMPLESIZE)/(float)SW_SAMPLERATE)); //Calculate samples based on samplesize samples out of hardware samplerate!
		//dolog("soundservice","Autodetect: %i samples buffer!",samples);
	}
	
	//Check for existant update!
	if (setSampleRate(handler,extradata,samplerate)) //Set?
	{
		dolog("soundservice","Sample rate changed to %f",samplerate);
		if (setStereo(handler,extradata,stereo)) //Set?
		{
			dolog("soundservice","Stereo changed to %i",stereo);
			#ifdef DEBUG_SOUNDALLOC
			dolog("soundservice","Channel changed and ready to run: handler: %p, extra data: %p, samplerate: %i, stereo: %i",handler,extradata,samplerate,stereo);
			dolog("soundservice",""); //Empty row!
			#endif
			return 1; //Already added and updated!
		}
	}

	uint_32 n; //For free allocation finding!
	lockaudio(); //Lock the audio!
	for (n=0;n<NUMITEMS(soundchannels);n++) //Try to find an available one!
	{
		if (!soundchannels[n].soundhandler) //Unused entry?
		{
			#ifdef DEBUG_SOUNDALLOC
			dolog("soundservice","Adding channel %s at %f samples/s, buffer every %i samples, Stereo: %i",name,samplerate,samples,stereo);
			#endif
			soundchannels[n].soundhandler = handler; //Set handler!
			soundchannels[n].extradata = extradata; //Extra data to be sent!
			soundchannels[n].sound.numsamples = samples; //Ammount of samples to buffer at a time!
			memset(&soundchannels[n].name,0,sizeof(soundchannels[n].name)); //Init name!
			strcpy(soundchannels[n].name,name); //Set a name to use for easy viewing/debugging!
			
			if (n>=soundchannels_used) //Past the ammount of channels used?
			{
				soundchannels_used = n;
				++soundchannels_used; //Update the ammount of sound channels used!
			}
			
			//Init volume, sample rate and stereo!
			setVolume(handler,extradata,100.0f); //Default volume to 100%
			if (!setSampleRate(handler,extradata,samplerate)) //The sample rate to use!
			{
				removechannel(handler,extradata,0);
				unlockaudio(1); //Unlock audio and start playing!
				return 0; //Abort!
			}
			if (!setStereo(handler,extradata,stereo)) //Stereo output?
			{
				removechannel(handler,extradata,0);
				unlockaudio(1); //Unlock audio and start playing!
				return 0; //Abort!
			}

			soundchannels[n].samplemethod = method; //The sampling method to use!

			//Finally, the samples themselves!
			soundchannels[n].sound.position = 0; //Make us refresh immediately!
			
			soundchannels[n].sound.length = samplesize(soundchannels[n].sound.numsamples,method); //Ammount of samples in the buffer, stereo quality (even if mono used)!
			soundchannels[n].sound.samples = zalloc(soundchannels[n].sound.length,"SW_Samples");
			
			soundchannels[n].init = 1; //We're a new channel ready to be filled with data!
			
			#ifdef DEBUG_SOUNDALLOC
			dolog("soundservice","Channel allocated and ready to run: handler: %p, extra data: %p, samplerate: %f, sample buffer size: %i, stereo: %i",soundchannels[n].soundhandler,soundchannels[n].extradata,soundchannels[n].samplerate,soundchannels[n].sound.numsamples,soundchannels[n].stereo);
			dolog("soundservice",""); //Empty row!
			#endif
			unlockaudio(1); //Unlock audio and start playing!
			return 1; //Add a channel and give the pointer to the current one!
		}
	}
	
	#ifdef DEBUG_SOUNDALLOC
	dolog("soundservice","Ran out of free channels!");
	#endif
	
	unlockaudio(1); //Unlock audio and start playing!
	return 0; //No channel available!
}

//is_hw: bit 1 set: do not pause, bit 2 set: do not resume playing.
void removechannel(SOUNDHANDLER handler, void *extradata, int is_hw) //Removes a sound handler from mixing, use is_hw=0 always, except for init/done of sound.c!
{
	if (__HW_DISABLED) return; //Disabled?
	if (!handler) return; //Can't remove no handler!
	uint_32 n; //For free allocation finding!
	lockaudio(); //Lock the audio!
	for (n=0;n<soundchannels_used;n++) //Try to find an available one!
	{
		if (soundchannels[n].soundhandler && (soundchannels[n].soundhandler==handler) && (soundchannels[n].extradata==extradata)) //Found?
		{
			#ifdef DEBUG_SOUNDALLOC
			dolog("soundservice","Releasing channel %s...",soundchannels[n].name);
			dolog("soundservice",""); //Empty row!
			#endif
			//releaseSamplerate(soundchannels[n].samplerate); //Release the sample rate we're using, if needed!
			if (soundchannels[n].sound.samples && soundchannels[n].sound.length) //Samples allocated?
			{
				freez((void **)&soundchannels[n].sound.samples,soundchannels[n].sound.length,"SW_Samples"); //Free samples!
				if (!soundchannels[n].sound.samples) //Freed?
				{
					soundchannels[n].sound.length = 0; //No length anymore!
				}
			}
			
			//Next remove our handler and the channel itself!
			soundchannels[n].soundhandler = NULL; //Stop the handler from availability!
			soundchannels[n].extradata = NULL; //No extra data anymore!

			#ifdef DEBUG_SOUNDALLOC
			dolog("soundservice","Channel %p:%p:%s released and ready to continue.",handler,extradata,soundchannels[n].name);
			dolog("soundservice",""); //Empty row!
			#endif
			
			if (n==(soundchannels_used-1)) //Final sound channel?
			{
				n = soundchannels_used;
				--n; //Final channel in use?
				while (1)
				{
					if (n==0 && !soundchannels[n].soundhandler) //Nothing found?
					{
						soundchannels_used = 0; //Nothing used!
						break; //Stop searching!
					}
					if (soundchannels[n].soundhandler) //Found a channel in use?
					{
						soundchannels_used = n;
						++soundchannels_used; //Found this channel!
						break; //Stop searching!
					}
					--n; //Decrease to the next channel!
				}
				//Now soundchannels_used contains the ammount of actually used sound channels!
			}
			memset(&soundchannels[n].name,0,sizeof(soundchannels[n].name)); //Clear the name!
			
			unlockaudio(!(is_hw&2)); //Unlock the audio and start playing again?
			return; //Done!
		}
	}
	unlockaudio(!(is_hw&2)); //Unlock the audio and start playing again?
}

void resetchannels()
{
	if (__HW_DISABLED) return; //Disabled?
	uint_32 n; //For free allocation finding!
	for (n=0;n<soundchannels_used;n++) //Try to find an available one!
	{
		if (soundchannels[n].soundhandler) //Allocated?
		{
			removechannel(soundchannels[n].soundhandler,soundchannels[n].extradata,3); //Remove the channel and stop all playback!
		}
	}
}

//OUR MIXING!

//Sample retrieval
static int_32 getsample_16(uint_32 channel, uint_32 position)
{
	word *y = soundchannels[channel].sound.samples;
	return unsigned2signed16(y[position]);
}

static int_32 getsample_16s(uint_32 channel, uint_32 position)
{
	sword *ys = soundchannels[channel].sound.samples;
	return ys[position];
}

static int_32 getsample_8(uint_32 channel, uint_32 position)
{
	byte *x = soundchannels[channel].sound.samples;	
	return (int_32)unsigned2signed8(x[position])<<8;
}

static int_32 getsample_8s(uint_32 channel, uint_32 position)
{
	sbyte *xs = soundchannels[channel].sound.samples;
	return (int_32)(xs[position]<<8);
}

static int_32 getsample_flt(uint_32 channel, uint_32 position)
{
	float *z = soundchannels[channel].sound.samples;
	return (int_32)((z[position]/FLT_MAX)*SHRT_MAX); //Convert to integer value!	
}

typedef int_32 (*SAMPLEHANDLER)(uint_32 channel, uint_32 position); //Sample handler!
static SAMPLEHANDLER handlers[5] = {getsample_16,getsample_8,getsample_16s,getsample_8s,getsample_flt};

static OPTINLINE int_32 getsample(uint_32 channel, uint_32 position) //Get 16-bit sample from sample buffer, convert as needed!
{
	register byte method = soundchannels[channel].samplemethod; //Load the method!
	if (method>5)
	{
		return 0; //Nothing!
	}
	return handlers[method](channel,position); //Execute handler if available!
}

//Simple macros for checking samples!
//Precalcs handling!
#define C_SAMPLEPOS(channel) (soundchannels[channel].sound.position)
#define C_BUFFERSIZE(channel) (soundchannels[channel].sound.numsamples)
#define C_BUFFERINC(channel) (soundchannels[channel].bufferinc)
//Use precalculated sample positions!
//#define C_SAMPLERATE(channel,position) (convert_samplerate[soundchannels[(channel)].samplerate][(position)])
#define C_SAMPLERATE(channel,position) (uint_32)(soundchannels[(channel)].convert_samplerate*((float)(position)))
#define C_GETSAMPLEPOS(channel,rchannel,time) (samplepos[soundchannels[(channel)].stereo][(((word)time)<<1)|(rchannel)])
#define C_STEREO(channel) (soundchannels[channel].stereo)
#define C_VOLUMEPERCENT(channel) (soundchannels[channel].volume_percent)
#define C_SAMPLE(channel,samplepos) getsample(channel,samplepos)

static OPTINLINE void mixchannels(sample_stereo_t *res) //Mixes the channels with each other at a specific time!
{
	//Process multichannel!
	#ifdef DEBUG_SOUNDBUFFER
	byte buffering; //We're buffered?
	#endif
	int_32 result_l, result_r; //The result!
	uint_32 n,  relsample=0; //Current channel and relative sample!
	word channelsleft; //Reversed of above!
	//Channel specific data
	float volume;
	sample_t sample_l, sample_r;
	uint_32 currentpos, bufferinc; //Current sample pos, buffered samples!
	
	//First, initialise our variables!
	channelsleft = soundchannels_used; //Ammount of channels left!
	if (!channelsleft || __HW_DISABLED) //No channels to mix or nothing to process?
	{
		res->l = res->r = 0.0f; //Nothin to process!
		return; //Done!
	}
	#ifdef DEBUG_SOUNDBUFFER
	buffering = 0; //initialise buffering flag!
	#endif
	//Result and active counters!
	result_l = result_r = 0; //Init to standard sum!
	n = 0; //Current channel number counter and active channel counter!
	
	//Now process all channels!
	nextmixing: //Mix the next channel!
		if (soundchannels[n].soundhandler) //Active?
		{
			if (soundchannels[n].samplerate && memprotect(soundchannels[n].sound.samples,soundchannels[n].sound.length,"SW_Samples") && samplepos[soundchannels[n].stereo] /*&& convert_samplerate[soundchannels[n].samplerate]*/) //Allocated all neccesary channel data?
			{
				currentpos = C_SAMPLEPOS(n); //Load the current position!
				if (soundchannels[n].init) //First sample to run?
				{
					currentpos = 0; //Reset samplepos!
					relsample = 0; //Reset relative sample!
					#ifdef DEBUG_SOUNDBUFFER
					dolog("soundservice","Initialising sound buffer...");
					dolog("soundservice","Buffering %i @ 0/%i samples; extra data: %p; name: %s",n,C_BUFFERSIZE(n),soundchannels[n].extradata,soundchannels[n].name);
					#endif
					//Buffer and update buffer position!
					soundchannels[n].bufferflags = soundchannels[n].soundhandler(soundchannels[n].sound.samples,C_BUFFERSIZE(n),C_STEREO(n),soundchannels[n].extradata); // Request next sample for this channel, also give our channel extra information!
					soundchannels[n].init = 0; //Not initialised!
				}
				else //Not initialised? We're a running channel!
				{
					bufferinc = C_BUFFERINC(n); //Load buffer increase rate!
					relsample = C_SAMPLERATE(n,currentpos); //Get the sample position of the destination samplerate!
					rebuffer: //Rebuffer check!
					if (relsample>=C_BUFFERSIZE(n)) //Expired, we've reached the end of the buffer (sample overflow)?
					{
						#ifdef DEBUG_SOUNDBUFFER
						buffering = 1; //We're buffering!
						dolog("soundservice","Buffering %i @ %i/%i samples; extra data: %p; name: %s",n,relsample,C_BUFFERSIZE(n),soundchannels[n].extradata,soundchannels[n].name);
						#endif
						//Buffer and update buffer position!
						soundchannels[n].bufferflags = soundchannels[n].soundhandler(soundchannels[n].sound.samples,C_BUFFERSIZE(n),C_STEREO(n),soundchannels[n].extradata); // Request next sample for this channel, also give our channel extra information!
						currentpos -= bufferinc; //Reset position in the next frame!
						relsample = C_SAMPLERATE(n,currentpos); //Get the sample rate for the new buffer!
						goto rebuffer; //Rebuffer if needed!
					} //Don't buffer!
					#ifdef DEBUG_SOUNDBUFFER
					if (buffering) //We were buffering?
					{
						buffering = 0;
						dolog("soundservice","Buffer ready. Mixing...");
					}
					#endif
				}

				//Now process the buffered sound itself!
				if (soundchannels[n].bufferflags&1) //Do we even got something buffered?
				{
					volume = C_VOLUMEPERCENT(n); //Retrieve the current volume!
					sample_l = C_SAMPLE(n,C_GETSAMPLEPOS(n,0,relsample)); //The composed sample, based on the relative position!
					sample_r = C_SAMPLE(n,C_GETSAMPLEPOS(n,1,relsample)); //The composed sample, based on the relative position!
					
					//Apply the channel volume!
					sample_l *= volume;
					sample_r *= volume;
					
					//Now we have the correct left and right channel data on our native samplerate.
					
					//Next, add the data to the mixer!
					result_l += sample_l; //Mix the channels equally together based on volume!
					result_r += sample_r; //See above!
				}

				//Finish up: update the values to be updated!
				++currentpos; //Next position on each channel!
				C_SAMPLEPOS(n) = currentpos; //Store the current position for next usage!
			}
		}
		if (--channelsleft) //Channels left?
		{
			++n; //Next channel!
			goto nextmixing; //Go and mix the next channel!
		}
	//result_l/r=a+b+...
	//multi_l/r=a*b*...
	//z=a+b-(ab/USHRT_MAX) => z=result_l/r-(multi_l/r / USHRT_MAX)
	
	//Apply hard clipping!
	result_l = (result_l>SHRT_MAX)?SHRT_MAX:((result_l<SHRT_MIN)?SHRT_MIN:result_l);
	result_r = (result_r>SHRT_MAX)?SHRT_MAX:((result_r<SHRT_MIN)?SHRT_MIN:result_r);

	res->l = (sample_t)result_l; //Left channel!
	res->r = (sample_t)result_r; //Right channel!
}

//Audio callbacks!

//Our standard actual audio callback!
void PSP_AudioCallback(void* buf, unsigned int length, void *userdata) {
	if (__HW_DISABLED) return; //Abort?
    sample_stereo_p ubuf = (sample_stereo_p) buf;	
	int i = 0;
	int j = length; //Length to process!
	for (;;) {
		mixchannels(&ubuf[i]); //L&R channel!
		if (!--j) break; //Next while left
		++i; //Next item!
	}
}

//SDL audio callback:

/* This function is called by SDL whenever the sound card
   needs more samples to play. It might be called from a
   separate thread, so we should be careful what we touch. */
uint_64 totaltime_audio = 0; //Total time!
uint_64 totaltimes_audio = 0; //Total times!
uint_32 totaltime_audio_avg = 1; //Total time of an average audio thread. Use this for synchronization with other time-taking hardware threads.
void SDL_AudioCallback(void *user_data, Uint8 *audio, int length)
{
	if (__HW_DISABLED) return; //Disabled?
	/* Clear the audio buffer so we can mix samples into it. */

	//Now, mix all channels!
	sample_stereo_t* ubuf = (sample_stereo_t*) audio; //Buffer!
	int i = 0;
	TicksHolder ticks;
	initTicksHolder(&ticks); //Init!
	getmspassed(&ticks); //Init!
	word reallength = length/sizeof(ubuf[0]); //Total length!
	for (;;) { //Process all samples needed!
		mixchannels(&ubuf[i]); //Fill both channels!
		if (!--reallength) break; //Next while left!
		++i; //Next item!
	}
	uint_64 mspassed = getmspassed(&ticks); //Load the time passed!
	totaltime_audio += mspassed; //Total time!
	++totaltimes_audio; //Total times increase!
	totaltime_audio_avg = (uint_32)SAFEDIV(totaltime_audio,totaltimes_audio); //Recalculate AVG audio time!
	#ifdef DEBUG_SOUNDSPEED
	char time1[20];
	char time2[20];
	convertTime(mspassed,&time1[0]); //Ms passed!
	convertTime(totaltime_audio_avg,&time2[0]); //Total time passed!
	if (soundchannels_used) //Any channels out there?
	{
		dolog("soundservice","Mixing %i samples took: %s, average: %s",length/sizeof(ubuf[0]),time1,time2); //Log it!
	}
	#endif
}



int SDLAudio_Loaded = 0; //Are we loaded (kept forever till quitting)

//Audio initialisation!
void initAudio() //Initialises audio subsystem!
{
	if (__HW_DISABLED) return; //Abort?

	if (!SDL_WasInit(SDL_INIT_AUDIO)) //Our own emulation?
	{
		//dolog("soundservice","Initialising PSP audio library...");
		pspAudioInit(); //Initialise audio library!
		//dolog("soundservice","Resetting channels...");
		resetchannels(); //Init all channels!
		//dolog("soundservice","Setting PSP audio callback...");
		calc_samplePos(); //Initialise sample position precalcs!
		pspAudioSetChannelCallback(0, PSP_AudioCallback, NULL); //Register our callback!
	}
	else if (SDL_WasInit(SDL_INIT_AUDIO)) //SDL rendering?
	{
		if (!SDLAudio_Loaded) //Not loaded yet?
		{
			//dolog("soundservice","Use SDL rendering...");
			SDL_PauseAudio(1); //Disable the thread!
			
			//dolog("soundservice","Setting desired audio device...");
			/* Open the audio device. The sound driver will try to give us
			the requested format, but it might not succeed. The 'obtained'
			structure will be filled in with the actual format data. */
			audiospecs.freq = HW_SAMPLERATE;	/* desired output sample rate */
			audiospecs.format = AUDIO_S16SYS;	/* request signed 16-bit samples */
			audiospecs.channels = 2;	/* ask for stereo */
			audiospecs.samples = SAMPLESIZE;	/* this is more or less discretionary */
			audiospecs.size = audiospecs.samples * audiospecs.channels * sizeof(sample_t);
			audiospecs.callback = &SDL_AudioCallback;
			audiospecs.userdata = NULL;	/* we don't need this */
			//dolog("soundservice","Opening audio device...");
			if (SDL_OpenAudio(&audiospecs, NULL) < 0)
			{
				//dolog("soundservice","Unable to open audio device: %s",SDL_GetError());
				raiseError("sound service","Unable to open audio device: %s", SDL_GetError());
				return; //Just to be safe!
			}
			//dolog("soundservice","Initialising channels...");
			memset(&soundchannels,0,sizeof(soundchannels)); //Initialise/reset all sound channels!
			SDLAudio_Loaded = 1; //We're loaded!
			//dolog("soundservice","Channels initialised@%fHz.",SW_SAMPLERATE);
		}
		else //Already loaded, needs reset?
		{
			//dolog("soundservice","Resetting channels...");
			SDL_PauseAudio(1); //Disable the thread!
			resetchannels(); //Reset the channels!
			//dolog("soundservice","Channels reset.");
		}
		//dolog("soundservice","Starting audio...");
		//Finish up to start playing!
		//dolog("soundservice","Calculating samplepos precalcs...");
		calc_samplePos(); //Initialise sample position precalcs!
		//dolog("soundservice","Starting audio...");
		SDL_PauseAudio(0); //Start playing!
		//dolog("soundservice","Device ready.");
	}
}

void doneAudio()
{
	if (__HW_DISABLED) return; //Abort?
	resetchannels(); //Stop all channels!
	//dolog("soundservice","Resetting channels for terminating...");
	//dolog("soundservice","Channels have been reset.");
	if (SDL_WasInit(SDL_INIT_AUDIO)) //Audio loaded?
	{
		//dolog("soundservice","Closing audio.");
		SDL_PauseAudio(1); //Lock the system!
		SDL_CloseAudio(); //Close the audio system!
		//dolog("soundservice","Audio closed.");
		SDLAudio_Loaded = 0; //Not loaded anymore!
	}
	free_samplePos(); //Free the sample position precalcs!
}